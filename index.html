<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ENDLESS QUEST - 覚醒の刻 -</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050505;
            --text: #e0e0e0;
            --border: #fff;
            --font: 'DotGothic16', sans-serif;
            --accent-red: #e53935;
            --accent-blue: #2979ff;
            --accent-ice: #80d8ff;
            --accent-yellow: #fdd835;
            --accent-green: #43a047;
            --accent-purple: #d500f9;
            --accent-cyan: #00bcd4;
            --window-border: 2px solid #fff;
            --window-radius: 4px;
            --anim-speed: 1;
        }

        body {
            background: var(--bg); color: var(--text); font-family: var(--font);
            margin: 0; display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Ruby Style */
        ruby { font-family: var(--font); }
        rt { font-size: 0.5em; color: var(--accent-cyan); font-weight: normal; user-select: none;}

        .game-container {
            width: 100%; max-width: 600px; height: 100%; max-height: 95vh;
            border: 4px double var(--border); border-radius: 8px; padding: 5px;
            box-sizing: border-box; display: flex; flex-direction: column;
            position: relative; background: #000;
            transition: box-shadow 0.5s, border-color 0.5s;
        }

        /* Speed Mode Class */
        .speed-x2 { --anim-speed: 2; }

        /* Absolute Defense Mode Style (Blue/Ice theme) */
        .defense-mode {
            border-color: var(--accent-ice);
            box-shadow: 0 0 20px var(--accent-ice), inset 0 0 50px rgba(0, 200, 255, 0.3);
            animation: pulse-defense 1s infinite alternate;
        }
        @keyframes pulse-defense { from { box-shadow: 0 0 10px #005; } to { box-shadow: 0 0 30px #0ff; } }

        /* Header & Progress */
        .header-row { display: flex; gap: 5px; align-items: center; margin-bottom: 5px; flex-shrink: 0; }
        .icon-btn {
            width: 30px; height: 30px; border: 1px solid #fff; border-radius: 4px;
            background: #222; color: #fff; font-weight: bold; font-size: 0.8rem;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
        }
        .speed-btn { width: 50px; font-size: 0.7rem; color: var(--accent-cyan); border-color: var(--accent-cyan); }
        .progress-container {
            flex-grow: 1; height: 10px; background: #222; border: 1px solid #555;
            position: relative; overflow: hidden;
        }
        .progress-bar {
            height: 100%; background: linear-gradient(90deg, #333, var(--accent-red));
            width: 0%; transition: width 0.5s;
        }
        .progress-text {
            position: absolute; top: -3px; left: 5px; font-size: 0.7rem; color: #fff; z-index: 2;
        }

        /* HUD */
        .hud {
            display: flex; flex-direction: column; border: var(--window-border);
            border-radius: var(--window-radius); padding: 5px 10px; margin-bottom: 5px;
            font-size: 0.85rem; background: #000; flex-shrink: 0;
        }
        .status-row { display: flex; justify-content: space-between; align-items: center; line-height: 1.3; }
        .val-hp { color: var(--accent-green); font-weight: bold; }
        .val-mp { color: var(--accent-blue); font-weight: bold;}
        .val-atk { color: var(--accent-red); }
        .val-def { color: var(--accent-blue); }
        .val-gold { color: var(--accent-yellow); }
        .chain-val { color: var(--accent-yellow); font-weight: bold; text-shadow: 0 0 5px orange; }
        
        /* Awakening Text updated to Defense */
        .awakening-text { 
            color: var(--accent-ice); font-weight: bold; 
            animation: blink 0.2s infinite alternate; display: none; margin-left:5px; font-size:0.8rem;
            text-shadow: 0 0 5px #0ff;
        }

        .gen-info { 
            font-size: 0.75rem; color: #aaa; border-top: 1px dashed #333; margin-top: 2px; padding-top: 2px;
            display: flex; flex-direction: column; gap: 1px;
        }
        .equip-row { display: flex; justify-content: space-between; }
        .hp-danger { color: var(--accent-red); animation: blink 0.2s infinite alternate; }
        .aura-indicator { font-size: 0.9rem; font-weight: bold; color: #fff; }
        .title-badge { color: var(--accent-purple); border: 1px solid var(--accent-purple); padding: 0 3px; font-size: 0.7rem; border-radius: 3px; margin-right: 5px; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.5; } }

        /* Stage */
        .stage {
            flex-grow: 1; display: flex; justify-content: center; align-items: center;
            position: relative; background: #111; border: var(--window-border);
            border-radius: var(--window-radius); margin-bottom: 5px; overflow: hidden;
            background-image: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)),
                repeating-linear-gradient(0deg, transparent 0, transparent 2px, #1a1a1a 2px, #1a1a1a 4px),
                repeating-linear-gradient(90deg, transparent 0, transparent 2px, #1a1a1a 2px, #1a1a1a 4px);
            background-size: cover; box-shadow: inset 0 0 50px #000;
        }
        
        .defense-mode .stage {
            background-image: radial-gradient(circle, rgba(0,20,50,0.4) 0%, rgba(0,0,0,0.9) 100%),
            repeating-linear-gradient(0deg, transparent 0, transparent 2px, #002 2px, #002 4px);
        }

        .character {
            width: 160px; height: 160px; position: relative;
            transition: transform 0.2s, filter 0.2s, opacity 0.5s;
            z-index: 5; filter: drop-shadow(0 10px 10px rgba(0,0,0,0.8));
        }

        /* Stage Overlays */
        .flash { position: absolute; top:0; left:0; width:100%; height:100%; background: white; opacity:0; pointer-events:none; z-index:99; transition: opacity 0.1s; }
        
        /* Just Guard Flash */
        .flash-invert {
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: white; mix-blend-mode: difference;
            opacity:0; pointer-events:none; z-index:98; 
        }
        .anim-invert { animation: invert-flash 0.2s ease-out; }
        @keyframes invert-flash { 0% { opacity: 1; } 100% { opacity: 0; } }

        .danger-overlay {
            position: absolute; top:0; left:0; right:0; bottom:0;
            box-shadow: inset 0 0 80px 30px rgba(200, 0, 0, 0.6);
            pointer-events: none; z-index: 90;
            animation: pulse-danger 0.8s infinite alternate; display: none;
        }
        @keyframes pulse-danger { from { opacity: 0.3; } to { opacity: 1; } }
        
        .cutin {
            position: absolute; top:50%; left:50%; transform:translate(-50%,-50%) scale(0);
            font-size: 3rem; color:var(--accent-yellow); -webkit-text-stroke: 1px #000; font-style: italic;
            text-shadow: 4px 4px 0 #d32f2f; background:rgba(0,0,0,0.8); padding:10px 30px; border:2px solid #fff;
            z-index:100; transition: transform 0.1s; white-space: nowrap; pointer-events: none;
        }
        /* Just Guard Style */
        .cutin.just { 
            color: #fff; text-shadow: 0 0 10px #0ff, 0 0 20px #00f; 
            border-color: #0ff; background: rgba(0,0,20,0.9);
            font-family: serif; letter-spacing: 0.1em;
        }
        
        .chain-pop {
             position: absolute; top:30%; left:50%; transform:translate(-50%,-50%) scale(0);
             font-size: 4rem; color:var(--accent-yellow); font-weight: bold; font-style: italic;
             text-shadow: 0 0 10px red; pointer-events: none; z-index: 95; opacity: 0;
             transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .damage-pop {
            position: absolute; left: 50%; transform: translateX(-50%);
            font-weight: bold; pointer-events: none; z-index: 20; opacity: 0; text-shadow: 2px 2px 0 #000;
        }
        .damage-pop.deal { top: 40%; font-size: 4rem; color: #fff; }
        .damage-pop.deal.crit { font-size: 5rem; color: #ffeb3b; text-shadow: 3px 3px 0 #d32f2f; z-index: 25; }
        .damage-pop.take { top: 60%; font-size: 4rem; color: #e53935; }
        .damage-pop.heal { top: 50%; font-size: 3rem; color: #43a047; }
        .damage-pop.block { top: 55%; font-size: 2.5rem; color: #80d8ff; text-shadow: 0 0 5px #00f; }
        .damage-pop.miss { top: 45%; font-size: 2rem; color: #aaa; }
        @keyframes pop-damage { 0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 15% { transform: translate(-50%, -30px) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -60px) scale(1); opacity: 0; } }

        /* Chest Display */
        #chest-display {
            position: absolute; top:0; left:0; width:100%; height:100%;
            display: none; justify-content: center; align-items: center;
            z-index: 40; background: rgba(0,0,0,0.85);
            gap: 10px; padding: 10px; box-sizing: border-box;
        }
        .chest-card {
            background: #111; border: 2px solid #555; border-radius: 6px; padding: 10px;
            width: 45%; max-width: 200px; display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 0 10px #000; position: relative;
        }
        .chest-card.new { border-color: var(--accent-yellow); background: #2a2200; box-shadow: 0 0 15px rgba(255,235,59,0.3); }
        .chest-label { font-size: 0.7rem; color: #aaa; background: #333; padding: 2px 5px; border-radius: 4px; margin-bottom: 5px; width: 100%; text-align: center; }
        .new .chest-label { color: #000; background: var(--accent-yellow); font-weight: bold; }
        .chest-icon { width: 48px; height: 48px; border: 1px solid #444; background: #000; margin-bottom: 5px; display: flex; justify-content: center; align-items: center; }
        .chest-name { font-size: 0.9rem; font-weight: bold; color: #fff; margin-bottom: 2px; text-align: center; height: 2.5em; overflow: hidden; line-height: 1.1; display:flex; align-items:center; justify-content:center;}
        .chest-stat { font-size: 1rem; color: #fff; font-weight: bold; }
        .chest-sub { font-size: 0.7rem; color: #ccc; min-height: 1rem;}
        .chest-effect { font-size: 0.7rem; color: var(--accent-purple); font-weight: bold; margin-top: 2px; text-shadow: 0 0 3px #a0f;}
        .chest-arrow { font-size: 2rem; color: #888; }
        
        /* Event Display */
        #event-display {
            position: absolute; top:0; left:0; width:100%; height:100%;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 40; background: rgba(0,0,0,0.9); text-align: center; color: #fff;
        }
        .event-title { font-size: 2rem; color: var(--accent-cyan); margin-bottom: 20px; text-shadow: 0 0 10px #0ff; }
        .event-desc { font-size: 1rem; margin-bottom: 30px; line-height: 1.5; padding: 0 20px;}

        /* Gauge */
        .gauge-area {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; height: 30px; background: #000; border: 2px solid #fff; border-radius: 4px;
            display: none; overflow: hidden; box-shadow: 0 0 15px #000; z-index: 30;
        }
        .gauge-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #1e88e5 0%, #fdd835 42%, #e53935 48%, #e53935 52%, #fdd835 58%, #1e88e5 100%); }
        .gauge-cursor { position: absolute; top: 0; bottom: 0; width: 4px; background: #fff; box-shadow: 0 0 8px #fff; left: 0%; }

        /* Log */
        .log-area {
            height: 90px; background: #000; border: var(--window-border); border-radius: var(--window-radius);
            margin-bottom: 5px; padding: 5px; overflow-y: hidden; font-size: 0.85rem; line-height: 1.5;
            display: flex; flex-direction: column-reverse; flex-shrink: 0;
        }
        .log-entry { border-bottom: 1px dashed #333; padding: 1px 0; }
        .log-entry.damage { color: var(--accent-red); }
        .log-entry.critical { color: var(--accent-yellow); font-weight: bold; }
        .log-entry.revive { color: var(--accent-green); }
        .log-entry.block { color: var(--accent-ice); text-shadow: 0 0 2px #0ff; }
        .log-entry.flavor { color: #888; font-style: italic; font-size: 0.8rem; }
        .log-entry.item { color: var(--accent-yellow); border: 1px solid #555; background: #222; text-align: center; }

        /* Controls */
        .controls { display: flex; flex-direction: column; height: 120px; flex-shrink: 0; }
        .main-btn { width: 100%; height: 100%; display: none; }
        .command-menu { display: none; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 5px; width: 100%; height: 100%; }

        button {
            border: 2px solid #fff; border-radius: 6px; background: #000; color: #fff;
            font-family: var(--font); font-size: 1.1rem; cursor: pointer; transition: all 0.1s; position: relative;
        }
        button:hover { background: #111; }
        button:active { transform: translateY(2px); }
        button:disabled { border-color: #555; color: #555; pointer-events: none; }
        
        .btn-stop { background: rgba(200, 0, 0, 0.4); color: #fff; font-weight: bold; font-size: 2rem; text-shadow: 2px 2px 0 #000; z-index: 50; }
        /* Guard Button Style */
        .btn-guard { background: rgba(0, 100, 255, 0.4); border-color: #0ff; color: #0ff; box-shadow: 0 0 15px #0ff; }
        
        /* Chest Command Buttons */
        #menu-chest { display: none; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; height: 100%; }
        .btn-get { border-color: var(--accent-yellow); color: var(--accent-yellow); background: #332200; font-weight: bold; font-size: 1.3rem; opacity: 0; transition: opacity 0.5s; }
        .btn-discard { border-color: #666; color: #888; background: #111; font-size: 1rem; opacity: 0; transition: opacity 0.5s; }

        /* Global Modals */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200; display: none;
            flex-direction: column; justify-content: center; align-items: center; padding: 20px;
            box-sizing: border-box; overflow-y: auto;
        }
        .modal-content { width: 100%; max-width: 500px; background: #111; border: 2px solid #fff; border-radius: 8px; padding: 15px; display: flex; flex-direction: column; gap: 15px; }
        
        .scroll-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 5px; max-height: 300px; overflow-y: auto; }
        .lib-item { border: 1px solid #555; padding: 2px; text-align: center; font-size: 0.6rem; opacity: 0.3; }
        .lib-item.got { border-color: var(--accent-yellow); opacity: 1; background: #111; }
        .lib-item.soul { border-color: var(--accent-purple); box-shadow: inset 0 0 5px #f0f; }
        
        .shop-btn { padding: 10px; border: 2px solid #fff; text-align: center; cursor: pointer; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.9rem;}
        
        /* Drama */
        .drama-window {
            position: absolute; top: 10px; left: 10px; right: 10px;
            background: rgba(0,0,0,0.95); border: 2px solid #fff; border-radius: 8px;
            padding: 10px; z-index: 80; display: none;
            flex-direction: row; align-items: center; gap: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.8);
        }
        .drama-actor-box { width: 48px; height: 48px; border: 1px solid #555; background: #222; flex-shrink: 0; }
        .drama-text-box { flex-grow: 1; display: flex; flex-direction: column; text-align: left; }
        .drama-name-label { color: var(--accent-yellow); font-weight: bold; font-size: 0.8rem; margin-bottom: 2px; }
        .drama-lines { font-size: 0.9rem; line-height: 1.3; color: #fff; }

        .click-start { position: absolute; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.9); color: #fff; display: flex; justify-content: center; align-items: center; z-index: 300; font-size: 1.5rem; cursor: pointer; flex-direction:column; gap:20px; text-align:center;}
        .item-get-pop {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
            background: #000; border: var(--window-border); border-radius: var(--window-radius);
            padding: 20px; text-align: center; z-index: 60; width: 80%; box-shadow: 0 0 20px #000; transition: transform 0.3s;
        }

        .anim-shake { animation: shake 0.4s; }
        .anim-lunge { animation: lunge 0.15s; }
        @keyframes shake { 0%{transform:translate(0,0)} 25%{transform:translate(-8px,8px)} 50%{transform:translate(8px,-8px)} 75%{transform:translate(-8px,8px)} 100%{transform:translate(0,0)} }
        @keyframes lunge { 0%{transform: scale(1);} 50% { transform: scale(1.3); } 100%{transform: scale(1);} }
    </style>
</head>
<body>

<div class="game-container" id="game-container">
    <div class="header-row">
        <button class="icon-btn" onclick="game.openHelp()">?</button>
        <button class="icon-btn speed-btn" id="btn-speed" onclick="game.toggleSpeed()">x1</button>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
            <div class="progress-text" id="progress-text">魔王城まで ???</div>
        </div>
    </div>

    <div class="hud">
        <div class="status-row">
            <span>第<span id="disp-gen">1</span>代 <span id="disp-title" class="title-badge" style="display:none"></span>(Lv<span id="disp-lv">1</span>)</span>
            <span class="gold-val"><span id="disp-gold">0</span> G</span>
        </div>
        <div class="status-row">
            <span>HP:<span id="disp-hp" class="val-hp">30</span></span>
            <span>MP:<span id="disp-mp" class="val-mp">10</span></span>
            <span>攻:<span id="disp-atk" class="val-atk">5</span> 守:<span id="disp-def" class="val-def">0</span></span>
        </div>
        <div class="gen-info">
            <div class="equip-row"><span>E:<span id="disp-weapon">素手</span></span> <span>E:<span id="disp-armor">服</span></span></div>
            <div class="equip-row" style="color:var(--accent-purple);"><span>A:<span id="disp-acc">なし</span></span></div>
            <div class="status-row">
                <span class="chain-val">CHAIN: <span id="disp-chain">0</span> <span id="awake-txt" class="awakening-text">≪絶対防御界≫</span></span>
                <span class="aura-indicator" id="disp-aura">READY</span>
            </div>
        </div>
    </div>

    <div class="stage" id="stage">
        <div class="flash" id="flash"></div>
        <div class="flash-invert" id="flash-invert"></div>
        <div class="danger-overlay" id="danger-overlay"></div>
        <div class="cutin" id="cutin"></div>
        <div class="chain-pop" id="chain-pop"></div>
        
        <!-- Drama Overlay -->
        <div id="drama-window" class="drama-window">
            <div id="drama-actor-box" class="drama-actor-box character"></div>
            <div class="drama-text-box">
                <div id="drama-name" class="drama-name-label">???</div>
                <div id="drama-text" class="drama-lines">...</div>
            </div>
        </div>

        <div class="gauge-area" id="gauge-area">
            <div class="gauge-bar"></div>
            <div class="gauge-cursor" id="gauge-cursor"></div>
        </div>

        <div id="damage-pop" class="damage-pop">0</div>
        <div id="enemy-slot" class="character"></div>

        <!-- NEW Chest Display (In-Stage) -->
        <div id="chest-display">
            <div class="chest-card current">
                <div class="chest-label">装備中</div>
                <div id="cur-icon" class="chest-icon"></div>
                <div id="cur-name" class="chest-name">素手</div>
                <div id="cur-stat" class="chest-stat">攻+0</div>
                <div id="cur-sub" class="chest-sub">なし</div>
                <div id="cur-effect" class="chest-effect"></div>
            </div>
            <div class="chest-arrow">➡</div>
            <div class="chest-card new">
                <div class="chest-label">宝箱</div>
                <div id="new-icon" class="chest-icon"></div>
                <div id="new-name" class="chest-name">???</div>
                <div id="new-stat" class="chest-stat">攻+?</div>
                <div id="new-sub" class="chest-sub">???</div>
                <div id="new-effect" class="chest-effect"></div>
            </div>
        </div>

        <!-- Event Display -->
        <div id="event-display">
            <div id="event-title" class="event-title">EVENT</div>
            <div id="event-desc" class="event-desc">...</div>
            <div id="event-choices" style="display:grid; gap:10px; width:100%; max-width:300px;"></div>
        </div>

        <div id="item-pop" class="item-get-pop">
            <div class="item-name">GET!</div>
            <div id="item-icon-slot" class="character" style="margin: 0 auto 10px; width: 64px; height: 64px;"></div>
            <div id="item-name-disp" class="item-name" style="font-size:1.2rem;"></div>
            <div style="color:#fff;">を手に入れた！</div>
        </div>
    </div>

    <div class="log-area" id="log">
        <div class="log-entry system">クリックして<ruby>冒険の書<rt>クロニクル</rt></ruby>を開く</div>
    </div>

    <div class="controls">
        <button id="btn-main" class="main-btn" onclick="game.handleMainBtn()">運命の抽選へ</button>
        
        <div id="menu-battle" class="command-menu">
            <button onclick="game.selectAttack()"><ruby>攻撃<rt>アタック</rt></ruby></button>
            <button onclick="game.openSkills()"><ruby>奥義<rt>スキル</rt></ruby></button>
            <button onclick="game.selectHeal()"><ruby>治癒<rt>ヒール</rt></ruby></button>
            <button style="border-color:var(--accent-blue); color:var(--accent-blue);" onclick="game.openLibrary()"><ruby>全知<rt>アーカイブ</rt></ruby></button>
        </div>
        
        <!-- Chest Menu (Displayed in controls area) -->
        <div id="menu-chest" class="command-menu">
            <button class="btn-get" id="btn-get" onclick="game.decideItem(true)">契約して装備</button>
            <button class="btn-discard" id="btn-discard" onclick="game.decideItem(false)">拒絶して進む</button>
        </div>

        <div id="menu-skills" class="command-menu" style="display:none;"></div>

        <!-- Button used for both Attack Gauge and Just Guard -->
        <button id="btn-stop" class="main-btn btn-stop" style="display:none;" onmousedown="game.handleActionBtn()" ontouchstart="game.handleActionBtn()">たたかう！</button>
    </div>

    <!-- Library -->
    <div id="lib-modal" class="modal-overlay">
        <div class="modal-content">
            <div style="display:flex; justify-content:space-between; width:100%; border-bottom:2px solid #fff; padding-bottom:10px; margin-bottom:10px;">
                <span><ruby>冒険の記録<rt>アカシックレコード</rt></ruby></span>
                <button style="width:auto; padding:5px 20px;" onclick="game.closeLibrary()">閉じる</button>
            </div>
            <div style="font-size:0.8rem; margin-bottom:5px; color:#aaa;">※紫枠はソウル(装飾品)</div>
            <div id="lib-grid" class="scroll-grid"></div>
        </div>
    </div>
    
    <!-- Help -->
    <div id="help-modal" class="modal-overlay">
        <div class="modal-content">
            <div style="display:flex; justify-content:space-between; width:100%; border-bottom:2px solid #fff; padding-bottom:10px; margin-bottom:10px;">
                <span>冒険の心得</span>
                <button style="width:auto; padding:5px 20px;" onclick="game.closeHelp()">閉じる</button>
            </div>
            <div style="text-align:left; height:300px; overflow-y:auto; font-size:0.9rem;">
                <p><strong>[基本]</strong><br>地下30階の魔王を討伐せよ。<br>世代(周回)が進むほど敵は強大になる。</p>
                <p><strong>[装飾品とソウル]</strong><br>3つ目の装備枠。敵が低確率で落とす「魂」は装飾品として装備可能。</p>
                <p><strong>[絶対防御界 (Defense Field)]</strong><br>CHAIN 5以上で自動発動。MPを消費してダメージを完全無効化する。MPが切れると解除。</p>
                <p><strong>[JUSTガード]</strong><br>敵の攻撃に合わせてボタンを押すと発動。ダメージ無効＋反撃。</p>
                <button class="reset-btn" style="border:1px solid #f44; color:#f44; margin-top:20px; padding:10px; width:100%;" onclick="game.resetSaveData()">セーブデータを削除</button>
            </div>
        </div>
    </div>

    <!-- Shop -->
    <div id="shop-modal" class="modal-overlay">
        <div class="modal-content">
            <div style="text-align:center; font-size:1.5rem; color:var(--accent-purple);">闇市 - <ruby>魂の等価交換<rt>ソウル・トレード</rt></ruby> -</div>
            <div style="text-align:center; margin-bottom:10px;">所持金: <span id="shop-gold" class="gold-val">0</span> G</div>
            <div class="scroll-grid" style="grid-template-columns: 1fr 1fr; gap:10px;">
                <div class="shop-btn" onclick="game.buyBoost('hp')"><div>HP+5</div><div style="color:var(--accent-yellow);">500G</div></div>
                <div class="shop-btn" onclick="game.buyBoost('mp')"><div>MP+2</div><div style="color:var(--accent-yellow);">500G</div></div>
                <div class="shop-btn" onclick="game.buyBoost('atk')"><div>攻+1</div><div style="color:var(--accent-yellow);">1000G</div></div>
                <div class="shop-btn" onclick="game.buyBoost('def')"><div>守+1</div><div style="color:var(--accent-yellow);">1000G</div></div>
                <div class="shop-btn" onclick="game.buyBoost('luck')"><div>運+2%</div><div style="color:var(--accent-yellow);">2000G</div></div>
            </div>
            <button style="margin-top:20px; width:100%; padding:15px;" onclick="game.softReset()">次世代へ託す</button>
        </div>
    </div>

    <div class="game-over-modal modal-overlay" id="modal-go">
        <h1 style="color:red; margin:0; font-size:3rem; text-shadow:2px 2px #fff;">GAME OVER</h1>
        <p>到達: 地下 <span id="final-score">0</span> 階</p>
        <button onclick="game.openShop()" style="padding:15px 40px; margin-top:20px; font-size:1.2rem;">闇市へ</button>
    </div>

    <div class="click-start" id="click-start" onclick="game.initAudio()">
        <div>ENDLESS QUEST 2.0<br>- 覚醒の刻 -</div>
        <div style="font-size:1rem; margin-top:20px;">画面をクリックしてスタート<br>(※音が出ます)</div>
    </div>
</div>

<script>
/** AUDIO */
class SoundManager {
    constructor() { this.ctx = null; this.bgmOscs = []; }
    init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
    playSE(type) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.connect(g); g.connect(this.ctx.destination);
        if (type==='select') { o.type='square'; o.frequency.setValueAtTime(440,t); o.frequency.exponentialRampToValueAtTime(880,t+0.05); g.gain.setValueAtTime(0.1,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.05); o.start(t); o.stop(t+0.05); }
        else if (type==='attack') { o.type='sawtooth'; o.frequency.setValueAtTime(150,t); o.frequency.exponentialRampToValueAtTime(50,t+0.1); g.gain.setValueAtTime(0.1,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.1); o.start(t); o.stop(t+0.1); }
        else if (type==='hit') { o.type='square'; o.frequency.setValueAtTime(100,t); g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.1); o.start(t); o.stop(t+0.1); }
        else if (type==='parry') { o.type='triangle'; o.frequency.setValueAtTime(800,t); o.frequency.linearRampToValueAtTime(1600,t+0.05); g.gain.setValueAtTime(0.3,t); g.gain.linearRampToValueAtTime(0,t+0.2); o.start(t); o.stop(t+0.2); }
        else if (type==='crit') { o.type='square'; o.frequency.setValueAtTime(880,t); o.frequency.setValueAtTime(1760,t+0.1); g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.3); o.start(t); o.stop(t+0.3); }
        else if (type === 'revive') {
            const freqs = [523.25, 659.25, 783.99, 1046.50, 1318.51, 2093.00]; 
            freqs.forEach((f, i) => {
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.ctx.destination); osc.type = 'triangle'; osc.frequency.value = f;
                gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.1, t + i*0.05 + 0.05); gain.gain.exponentialRampToValueAtTime(0.001, t + i*0.05 + 1.5);
                osc.start(t + i*0.05); osc.stop(t + i*0.05 + 1.5);
            });
            o.disconnect();
        } else if (type==='coin') { o.type='sine'; o.frequency.setValueAtTime(1200,t); g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.2); o.start(t); o.stop(t+0.2); }
        else if (type==='metal') { o.type='square'; o.frequency.setValueAtTime(1500,t); g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.05); o.start(t); o.stop(t+0.05); }
    }
    playBGM(type) {
        if (!this.ctx) return; this.stopBGM();
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); const f = this.ctx.createBiquadFilter();
        o.connect(f); f.connect(g); g.connect(this.ctx.destination);
        o.type='sawtooth'; f.type='lowpass'; f.frequency.value=300;
        const t = this.ctx.currentTime;
        if(type==='battle'){ o.frequency.setValueAtTime(55,t); g.gain.value=0.05; }
        else if(type==='boss'){ o.frequency.setValueAtTime(40,t); g.gain.value=0.08; }
        else if(type==='awake'){ o.frequency.setValueAtTime(110,t); g.gain.value=0.08; f.frequency.setValueAtTime(600, t); o.type='square';}
        else if(type==='clear'){ o.frequency.setValueAtTime(440,t); g.gain.value=0.03; }
        o.start(); this.bgmOscs.push({o,g});
    }
    stopBGM() { this.bgmOscs.forEach(obj=>{try{obj.o.stop();obj.o.disconnect();}catch(e){}}); this.bgmOscs=[]; }
}

/** DATA */
const SAVE_KEY = 'EQ_SAVE_V300';
const WEAPON_PREFIXES = [
    {t:"朽ちた",r:"クチタ"}, {t:"鉄塊の",r:"テッカイノ"}, {t:"煉獄の",r:"レンゴクノ"}, {t:"名工の",r:"メイコウノ"}, 
    {t:"虚無の",r:"ヴォイド"}, {t:"絶対零度",r:"アブソリュート"}, {t:"雷光の",r:"ライトニング"}, {t:"聖なる",r:"ホーリー"}, 
    {t:"深淵の",r:"アビス"}, {t:"神話の",r:"ミソロジー"}, {t:"黄昏の",r:"トワイライト"}, {t:"終焉の",r:"カタストロフィ"},
    {t:"神殺しの",r:"ゴッドスレイヤー"}, {t:"禁忌の",r:"タブー"}, {t:"幻影の",r:"ファントム"}, {t:"血塗られた",r:"ブラッディ"}
];
const WEAPON_COLORS = ["#888", "#abc", "#d44", "#da8", "#a4a", "#8df", "#fd0", "#ff8", "#808", "#f4f", "#f84", "#444", "#f00", "#606", "#88f", "#900"];

function generateSVG(data, colorOverride=null, metal=false) {
    if (!data || !data.pixels) return '<svg viewBox="0 0 16 16"></svg>';
    let rects = ""; const baseColor = colorOverride || data.color;
    data.pixels.forEach(p => { rects += `<rect x="${p.x}" y="${p.y}" width="${p.w}" height="${p.h}" fill="${p.c||baseColor}" shape-rendering="crispEdges"/>`; });
    let filter = "filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.5));";
    if (metal) filter = "filter: drop-shadow(0 0 5px #fff) brightness(1.5) contrast(1.2);";
    return `<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="image-rendering: pixelated; width: 100%; height: 100%; ${filter}">${rects}</svg>`;
}

const SPRITES = {
    stick: { color: "#a84", pixels: [{x:7,y:3,w:2,h:10}] },
    club: { color: "#953", pixels: [{x:6,y:2,w:4,h:8},{x:7,y:10,w:2,h:3}] },
    sword: { color:"#ccc", pixels:[{x:7,y:12,w:2,h:3,c:"#444"},{x:5,y:11,w:6,h:1,c:"#666"},{x:6,y:1,w:4,h:10},{x:7,y:2,w:2,h:9,c:"#fff"}] },
    axe: { color:"#888", pixels:[{x:7,y:12,w:2,h:3},{x:7,y:3,w:2,h:9},{x:4,y:2,w:8,h:4},{x:4,y:2,w:1,h:2,c:"#fff"}] },
    spear: { color:"#ccc", pixels:[{x:7,y:12,w:2,h:3},{x:7,y:4,w:2,h:8,c:"#642"},{x:6,y:1,w:4,h:4}] },
    hammer: { color:"#654", pixels:[{x:7,y:6,w:2,h:8,c:"#642"},{x:3,y:2,w:10,h:4}] },
    wand: { color:"#a4a", pixels:[{x:7,y:6,w:2,h:8,c:"#642"},{x:5,y:2,w:6,h:4},{x:6,y:3,w:4,h:2,c:"#fff"}] },
    scythe: { color:"#a4e", pixels:[{x:8,y:2,w:2,h:12},{x:4,y:2,w:8,h:2,c:"#ccc"},{x:2,y:2,w:2,h:6,c:"#fff"}]},
    a_cloth: { color: "#dca", pixels: [{x:4,y:3,w:8,h:10},{x:3,y:4,w:2,h:4},{x:11,y:4,w:2,h:4}] },
    a_leather: { color: "#a64", pixels: [{x:4,y:3,w:8,h:10},{x:3,y:4,w:2,h:4},{x:11,y:4,w:2,h:4},{x:6,y:4,w:4,h:6,c:"#842"}] },
    a_chain: { color: "#888", pixels: [{x:4,y:2,w:8,h:11,c:"#666"},{x:2,y:3,w:12,h:4,c:"#888"},{x:5,y:5,w:6,h:6,c:"#aaa"}] },
    a_iron: { color: "#abc", pixels: [{x:3,y:2,w:10,h:10},{x:2,y:3,w:12,h:4},{x:5,y:4,w:6,h:8,c:"#def"}] },
    a_steel: { color: "#fff", pixels: [{x:3,y:2,w:10,h:11},{x:1,y:3,w:14,h:4},{x:6,y:4,w:4,h:6,c:"#888"}] },
    a_dragon: { color: "#a44", pixels: [{x:2,y:2,w:12,h:12},{x:4,y:4,w:8,h:8,c:"#f84"},{x:6,y:6,w:4,h:4,c:"#fd0"}] },
    a_hero: { color: "#48f", pixels: [{x:2,y:2,w:12,h:12},{x:4,y:4,w:8,h:8,c:"#da0"},{x:6,y:6,w:4,h:4,c:"#f00"}] },
    ring: { color: "#fd0", pixels: [{x:5,y:4,w:6,h:8,c:"#fd0"},{x:6,y:5,w:4,h:6,c:"#000"},{x:7,y:3,w:2,h:2,c:"#f00"}] },
    amulet: { color: "#a8f", pixels: [{x:6,y:1,w:4,h:10,c:"#aaa"},{x:5,y:10,w:6,h:4,c:"#a8f"}] },
    soul: { color: "#0ff", pixels: [{x:6,y:3,w:4,h:8,c:"#0ff"},{x:4,y:5,w:8,h:4,c:"#0ff"},{x:5,y:5,w:2,h:2,c:"#fff"},{x:9,y:5,w:2,h:2,c:"#fff"}] },
    // Enemies
    slime: { color: "#48f", pixels: [{x:7,y:4,w:2,h:2},{x:5,y:6,w:6,h:3},{x:3,y:9,w:10,h:5},{x:2,y:12,w:12,h:2},{x:5,y:8,w:2,h:2,c:"#fff"},{x:6,y:9,w:1,h:1,c:"#000"},{x:9,y:8,w:2,h:2,c:"#fff"},{x:10,y:9,w:1,h:1,c:"#000"},{x:6,y:11,w:4,h:1,c:"#a00"}] },
    bat: { color: "#222", pixels: [{x:2,y:2,w:4,h:4,c:"#404"},{x:10,y:2,w:4,h:4,c:"#404"},{x:5,y:5,w:6,h:6},{x:6,y:6,w:1,h:2,c:"#fff"},{x:9,y:6,w:1,h:2,c:"#fff"}] },
    skeleton: { color: "#ddd", pixels: [{x:6,y:2,w:4,h:4,c:"#fff"},{x:6,y:3,w:1,h:1,c:"#000"},{x:9,y:3,w:1,h:1,c:"#000"},{x:7,y:7,w:2,h:5},{x:5,y:8,w:6,h:1},{x:12,y:5,w:2,h:7,c:"#888"}] },
    knight: { color: "#889", pixels: [{x:6,y:1,w:4,h:5,c:"#aaa"},{x:4,y:6,w:8,h:6},{x:2,y:6,w:2,h:5,c:"#aaa"},{x:12,y:6,w:2,h:5,c:"#aaa"},{x:5,y:12,w:2,h:4,c:"#444"},{x:1,y:4,w:2,h:8,c:"#ccc"}] },
    dragon: { color: "#62a", pixels: [{x:4,y:1,w:3,h:5,c:"#4a2"},{x:6,y:2,w:1,h:1,c:"#fc0"},{x:2,y:3,w:2,h:4,c:"#4a2"},{x:5,y:6,w:6,h:6},{x:0,y:2,w:4,h:8,c:"#a4e"},{x:12,y:2,w:4,h:8,c:"#a4e"},{x:8,y:9,w:6,h:2,c:"#4a2"}] },
    boss: { color: "#222", pixels: [{x:5,y:0,w:6,h:6,c:"#ddd"},{x:6,y:3,w:1,h:1,c:"#f00"},{x:9,y:3,w:1,h:1,c:"#f00"},{x:3,y:6,w:10,h:8},{x:3,y:6,w:10,h:2,c:"#808"},{x:1,y:6,w:2,h:8,c:"#ccc"},{x:13,y:6,w:2,h:8,c:"#ccc"}] },
    goldman: { color: "#fd0", pixels: [{x:4,y:2,w:8,h:6},{x:2,y:4,w:2,h:6},{x:12,y:4,w:2,h:6},{x:5,y:9,w:2,h:5},{x:9,y:9,w:2,h:5},{x:6,y:4,w:1,h:1,c:"#000"},{x:9,y:4,w:1,h:1,c:"#000"}] },
    rabbit: { color: "#da8", pixels: [{x:6,y:2,w:1,h:4},{x:9,y:2,w:1,h:4},{x:5,y:6,w:6,h:5},{x:6,y:7,w:1,h:1,c:"#000"},{x:9,y:7,w:1,h:1,c:"#000"},{x:7,y:9,w:2,h:1,c:"#f88"}] },
    wizard: { color: "#808", pixels: [{x:6,y:2,w:4,h:3,c:"#d0d"},{x:5,y:5,w:6,h:4,c:"#fcc"},{x:4,y:7,w:8,h:7,c:"#808"},{x:12,y:4,w:2,h:8,c:"#a62"},{x:2,y:8,w:2,h:4,c:"#fcc"}] },
    golem: { color: "#b84", pixels: [{x:5,y:1,w:6,h:5,c:"#c96"},{x:6,y:3,w:1,h:1,c:"#000"},{x:9,y:3,w:1,h:1,c:"#000"},{x:2,y:6,w:12,h:6,c:"#c96"},{x:1,y:6,w:2,h:8,c:"#a75"},{x:13,y:6,w:2,h:8,c:"#a75"}] },
    demon: { color: "#a22", pixels: [{x:4,y:1,w:2,h:3,c:"#fff"},{x:10,y:1,w:2,h:3,c:"#fff"},{x:4,y:4,w:8,h:5,c:"#d22"},{x:3,y:9,w:10,h:5,c:"#a22"},{x:0,y:2,w:4,h:6,c:"#202"},{x:12,y:2,w:4,h:6,c:"#202"}] },
    metal_s: { color: "#ccc", pixels: [{x:7,y:5,w:2,h:2,c:"#eee"},{x:5,y:7,w:6,h:3,c:"#ccc"},{x:3,y:10,w:10,h:4,c:"#aaa"},{x:5,y:9,w:2,h:2,c:"#fff"},{x:6,y:10,w:1,h:1,c:"#000"},{x:9,y:9,w:2,h:2,c:"#fff"},{x:10,y:10,w:1,h:1,c:"#000"}] },
    asura: { color: "#a4e", pixels: [{x:5,y:1,w:6,h:5,c:"#d8d"},{x:4,y:6,w:8,h:6},{x:2,y:4,w:2,h:4},{x:12,y:4,w:2,h:4},{x:2,y:9,w:2,h:4},{x:12,y:9,w:2,h:4},{x:5,y:12,w:2,h:4,c:"#444"},{x:9,y:12,w:2,h:4,c:"#444"}] },
    general: { color: "#667", pixels: [{x:5,y:0,w:6,h:6,c:"#889"},{x:3,y:6,w:10,h:8,c:"#445"},{x:1,y:6,w:2,h:6,c:"#aaa"},{x:13,y:6,w:2,h:6,c:"#aaa"},{x:5,y:14,w:2,h:2,c:"#222"},{x:9,y:14,w:2,h:2,c:"#222"}] },
    mimic: { color: "#d84", pixels: [{x:3,y:4,w:10,h:8},{x:2,y:4,w:1,h:8},{x:13,y:4,w:1,h:8},{x:4,y:3,w:8,h:1},{x:6,y:6,w:1,h:2,c:"#fff"},{x:9,y:6,w:1,h:2,c:"#fff"},{x:4,y:9,w:8,h:2,c:"#800"}] },
    ghost: { color: "#eee", pixels: [{x:5,y:2,w:6,h:8,c:"#fff"},{x:3,y:6,w:10,h:6,c:"#eee"},{x:5,y:5,w:2,h:2,c:"#000"},{x:9,y:5,w:2,h:2,c:"#000"},{x:6,y:9,w:4,h:2,c:"#f00"}] },
    reaper: { color: "#222", pixels: [{x:6,y:2,w:4,h:4,c:"#fff"},{x:5,y:6,w:6,h:8},{x:2,y:4,w:12,h:2},{x:12,y:2,w:2,h:12,c:"#888"}] },
    // NEW ENEMIES
    cerberus: { color: "#840", pixels: [{x:1,y:4,w:4,h:4},{x:6,y:2,w:4,h:6},{x:11,y:4,w:4,h:4},{x:2,y:5,w:1,h:1,c:"#f00"},{x:7,y:4,w:1,h:1,c:"#f00"},{x:12,y:5,w:1,h:1,c:"#f00"},{x:4,y:8,w:8,h:6,c:"#630"}]},
    dullahan: { color: "#334", pixels: [{x:6,y:6,w:6,h:8},{x:1,y:6,w:3,h:4,c:"#da8"},{x:1,y:5,w:3,h:2,c:"#222"},{x:10,y:2,w:2,h:10,c:"#888"}]},
    lich: { color: "#426", pixels: [{x:6,y:2,w:4,h:4,c:"#eea"},{x:5,y:6,w:6,h:8,c:"#426"},{x:3,y:3,w:1,h:10,c:"#a84"},{x:2,y:2,w:3,h:1,c:"#d4f"}]},
    chimera: { color: "#d84", pixels: [{x:4,y:4,w:8,h:6},{x:2,y:2,w:4,h:4,c:"#da8"},{x:10,y:2,w:4,h:4,c:"#4a2"},{x:12,y:6,w:2,h:6,c:"#a22"}]},
    angel: { color: "#eea", pixels: [{x:6,y:2,w:4,h:4},{x:1,y:3,w:4,h:8,c:"#fff"},{x:11,y:3,w:4,h:8,c:"#fff"},{x:6,y:6,w:4,h:8,c:"#ccc"},{x:6,y:1,w:4,h:1,c:"#fd0"}]},
    fallen: { color: "#222", pixels: [{x:6,y:2,w:4,h:4,c:"#ccc"},{x:1,y:3,w:4,h:8,c:"#222"},{x:11,y:3,w:4,h:8,c:"#222"},{x:6,y:6,w:4,h:8,c:"#444"}]},

    // NPC
    npc_princess: { color: "#fca", pixels: [{x:6,y:2,w:4,h:4,c:"#fa8"},{x:5,y:6,w:6,h:8,c:"#f8a"},{x:4,y:7,w:2,h:4,c:"#fca"},{x:10,y:7,w:2,h:4,c:"#fca"}] },
    npc_king: { color: "#fca", pixels: [{x:5,y:1,w:6,h:5,c:"#fff"},{x:6,y:0,w:4,h:2,c:"#fd0"},{x:4,y:6,w:8,h:8,c:"#a22"},{x:6,y:7,w:4,h:6,c:"#fff"}] },
    npc_friend: { color: "#fca", pixels: [{x:6,y:2,w:4,h:4,c:"#642"},{x:5,y:6,w:6,h:6,c:"#48a"},{x:4,y:7,w:2,h:4,c:"#fca"}] },
    npc_healer: { color: "#fca", pixels: [{x:6,y:2,w:4,h:4,c:"#fcc"},{x:5,y:6,w:6,h:6,c:"#fff"},{x:7,y:8,w:2,h:2,c:"#8f8"},{x:4,y:7,w:2,h:4,c:"#fca"}] },
};

const SKILLS = [
    { id: "fire", name: "<ruby>紅蓮<rt>グレン</rt></ruby>の<ruby>腕<rt>カイナ</rt></ruby>", mp: 3, dmg: 2.0, msg: "焼き尽くせ！" },
    { id: "vac", name: "<ruby>断空<rt>ダンクウ</rt></ruby>の<ruby>太刀<rt>タチ</rt></ruby>", mp: 5, dmg: 2.5, msg: "空を切る！" },
    { id: "falcon", name: "<ruby>幻影<rt>ゲンエイ</rt></ruby><ruby>連撃<rt>レンゲキ</rt></ruby>", mp: 8, dmg: 1.0, times: 2, msg: "残像だ..." },
    { id: "gigadein", name: "<ruby>天雷<rt>テンライ</rt></ruby><ruby>招来<rt>ショウライ</rt></ruby>", mp: 15, dmg: 5.0, msg: "消え失せろ！" },
    { id: "heal", name: "<ruby>因果<rt>インガ</rt></ruby><ruby>逆転<rt>ギャクテン</rt></ruby>", mp: 5, heal: 60, type: "heal", msg: "時を戻す！" },
    { id: "smash", name: "<ruby>脳天<rt>ノウテン</rt></ruby><ruby>唐竹<rt>カラタケ</rt></ruby>", mp: 4, dmg: 2.2, msg: "砕け散れ！" },
    { id: "all", name: "<ruby>旋風<rt>センプウ</rt></ruby><ruby>乱舞<rt>ランブ</rt></ruby>", mp: 6, dmg: 1.8, msg: "一網打尽！" },
    { id: "crit", name: "<ruby>瞬獄殺<rt>シュンゴクサツ</rt></ruby>", mp: 4, dmg: 1.2, msg: "死角なし！" },
    { id: "magic", name: "<ruby>黒炎弾<rt>コクエンダン</rt></ruby>", mp: 6, dmg: 3.0, msg: "闇に飲まれよ！" }
];

const ITEMS = [
    { id: "stick", type:"w", name: "<ruby>始<rt>ハジ</rt></ruby>まりの<ruby>枝<rt>エダ</rt></ruby>", atk: 2, prob: 0.2, sprite: "stick", color: "#a84" },
    { id: "club", type:"w", name: "<ruby>蛮族<rt>バンゾク</rt></ruby>の<ruby>棍棒<rt>コンボウ</rt></ruby>", atk: 4, prob: 0.15, sprite: "club", color: "#953", skillId: "smash" },
    { id: "cloth", type:"a", name: "<ruby>旅人<rt>タビビト</rt></ruby>の<ruby>外套<rt>ガイトウ</rt></ruby>", def: 1, prob: 0.2, sprite: "a_cloth", color: "#dca" },
    { id: "leather", type:"a", name: "<ruby>獣<rt>ケモノ</rt></ruby>の<ruby>皮鎧<rt>カワヨロイ</rt></ruby>", def: 3, prob: 0.15, sprite: "a_leather", color: "#a64" },
    // Artifacts
    { id: "ring_str", type:"acc", name: "<ruby>剛力<rt>ゴウリキ</rt></ruby>の<ruby>指輪<rt>リング</rt></ruby>", atk: 5, prob: 0.1, sprite: "ring", color: "#f44" },
    { id: "amu_pro", type:"acc", name: "<ruby>守護<rt>シュゴ</rt></ruby>の<ruby>護符<rt>アミュレット</rt></ruby>", def: 5, prob: 0.1, sprite: "amulet", color: "#48f" },
    { id: "acc_vamp", type:"acc", name: "<ruby>吸血鬼<rt>ヴァンパイア</rt></ruby>の<ruby>牙<rt>キバ</rt></ruby>", atk: 10, prob: 0.05, sprite: "amulet", color: "#a00", effect: "drain", effectName: "吸血" },
    { id: "acc_gold", type:"acc", name: "<ruby>強欲<rt>グリード</rt></ruby>の<ruby>壺<rt>ツボ</rt></ruby>", def: 0, prob: 0.05, sprite: "ring", color: "#fd0", effect: "greed", effectName: "富豪" },
    { id: "acc_revive", type:"acc", name: "フェニックスの<ruby>尾<rt>オ</rt></ruby>", def: 2, prob: 0.01, sprite: "soul", color: "#f80", effect: "rebirth", effectName: "再誕" },
];
const W_TYPES = [{id:"sword",name:"剣",base:8,sp:"sword",sk:"fire"},{id:"axe",name:"斧",base:10,sp:"axe",sk:"smash"},{id:"spear",name:"槍",base:9,sp:"spear",sk:"crit"},{id:"hammer",name:"槌",base:12,sp:"hammer",sk:"all"},{id:"wand",name:"杖",base:6,sp:"wand",sk:"magic"}];
const A_TYPES = [{id:"chain",name:"鎖帷子",base:5,sp:"a_chain"},{id:"iron",name:"鉄の鎧",base:10,sp:"a_iron"},{id:"steel",name:"鋼の鎧",base:15,sp:"a_steel"},{id:"dragon",name:"竜の鎧",base:22,sp:"a_dragon"},{id:"hero",name:"光の鎧",base:30,sp:"a_hero"}];

W_TYPES.forEach(t=>{ 
    WEAPON_PREFIXES.forEach((pre,i)=>{ 
        const rName = `<ruby>${pre.t}<rt>${pre.r}</rt></ruby>${t.name}`;
        ITEMS.push({id:`${t.id}_${i}`,type:"w",name:rName,atk:t.base+(i*5),prob:0.1/(i+1),sprite:t.sp,color:WEAPON_COLORS[i],skillId:t.sk}); 
    }); 
});
A_TYPES.forEach(t=>{ 
    WEAPON_PREFIXES.forEach((pre,i)=>{ 
        const rName = `<ruby>${pre.t}<rt>${pre.r}</rt></ruby>${t.name}`;
        ITEMS.push({id:`${t.id}_${i}`,type:"a",name:rName,def:t.base+(i*3),prob:0.1/(i+1),sprite:t.sp,color:WEAPON_COLORS[i]}); 
    }); 
});

ITEMS.push(
    { id: "hero_w", type:"w", name: "ラグナロク", atk: 80, prob: 0.005, sprite: "sword", color: "#48f", skillId: "gigadein" },
    { id: "metal_w", type:"w", name: "<ruby>魔剣<rt>マケン</rt></ruby>オメガ", atk: 40, prob: 0.01, sprite: "sword", color: "#ccc", skillId: "falcon" },
);

// Soul Definitions
const SOULS = {
    slime: { name: "スライムの<ruby>魂<rt>ソウル</rt></ruby>", effect: "regen", effectName: "再生", color: "#48f" },
    bat: { name: "コウモリの<ruby>魂<rt>ソウル</rt></ruby>", effect: "haste", effectName: "神速", color: "#222" },
    goldman: { name: "黄金の<ruby>魂<rt>ソウル</rt></ruby>", effect: "greed", effectName: "富豪", color: "#fd0" },
    dragon: { name: "<ruby>竜<rt>ドラゴン</rt></ruby>の<ruby>魂<rt>ソウル</rt></ruby>", effect: "atk_up", effectName: "剛腕", color: "#62a", val: 50 },
    mimic: { name: "<ruby>人食い箱<rt>ミミック</rt></ruby>の<ruby>魂<rt>ソウル</rt></ruby>", effect: "crit_up", effectName: "必殺", color: "#d84" },
    boss: { name: "<ruby>魔王<rt>ダークロード</rt></ruby>の<ruby>魂<rt>ソウル</rt></ruby>", effect: "all_up", effectName: "覇王", color: "#f00", val: 100 },
    reaper: { name: "<ruby>死神<rt>デス</rt></ruby>の<ruby>魂<rt>ソウル</rt></ruby>", effect: "drain", effectName: "吸血", color: "#222" }
};

const FLAVOR_TEXTS = ["ククク…<ruby>力<rt>フォース</rt></ruby>が溢れてくる…", "右腕が…<ruby>疼<rt>ウズ</rt></ruby>く…", "<ruby>魔力<rt>マナ</rt></ruby>が共鳴している…", "この痛み…心地よい…", "我に潜む<ruby>闇<rt>ダークネス</rt></ruby>が騒ぐ…", "見えた…死の<ruby>線<rt>ライン</rt></ruby>が…", "<ruby>封印<rt>シール</rt></ruby>が解けそうだ…", "世界が…私を拒絶しているのか？"];
const RATES = [ { name: "絶望", color: "#444", rate: 0.05 }, { name: "凡人", color: "#fff", rate: 0.10 }, { name: "修羅", color: "#48f", rate: 0.20 }, { name: "英雄", color: "#fd0", rate: 0.30 }, { name: "伝説", color: "#f44", rate: 0.50 }, { name: "神話", color: "magenta", rate: 0.65 } ];

// New Text Data
const GUARD_TEXTS = [
    {t:"見切",r:"ミキリ"},{t:"瞬断",r:"シュンダン"},{t:"絶無",r:"ゼツム"},
    {t:"相殺",r:"ソウサイ"},{t:"虚空",r:"コクウ"},{t:"凪",r:"ナギ"}
];
const TITLES = [
    { id: "t_survivor", name: "<ruby>生存者<rt>サバイバー</rt></ruby>", cond: (g)=>g.generation>2, eff: "HP+20%" },
    { id: "t_godspeed", name: "<ruby>神速<rt>ソニック</rt></ruby>", cond: (g)=>g.fastClears>5, eff: "AGI+10%" },
    { id: "t_immortal", name: "<ruby>不死者<rt>ノスフェラトゥ</rt></ruby>", cond: (g)=>g.reviveCount>0, eff: "REVIVE+" },
    { id: "t_unscathed", name: "<ruby>無傷<rt>パーフェクト</rt></ruby>の<ruby>帝王<rt>カイザー</rt></ruby>", cond: (g)=>g.noDamageStreak>5, eff: "LUCK+" }
];

// Expanded Dialogues
const TALK_PATTERNS = {
    start: ["貴様の命運は尽きた！", "その魂、我が糧となれ！", "絶望を教えてやろう", "フフフ…楽しませてくれよ？", "我が闇に平伏せ！", "この領域に踏み入るとは…", "死へのカウントダウンだ", "恐怖に歪む顔が見たい…"],
    hit: ["貴様…やるな？", "計算外だ…", "効かぬわ！", "ふん、小賢しい", "バカな…", "この私が…押されている？"],
    pinch: ["まだだ…まだ終わらんよ！", "本気を出させるとは…", "後悔するぞ…", "闇の力よ！我に集え！", "貴様を道連れにしてやる！"],
    die: ["バカな…私が敗れるとは…", "見事だ…", "これが…敗北の味か…", "第二形態への布石に過ぎん…", "闇は…滅びぬ…", "グフッ…！"]
};

let game = null;

class Game {
    constructor() {
        this.sound = new SoundManager();
        this.el = {}; 
        this.resetInternalState();
        this.targetLv = 30; 
        this.gaugeVal = 0; this.gaugeDir = 1; this.gaugeSpeed = 2;
        this.pendingItem = null;
        this.chain = 0;
        this.isDefenseMode = false;
        this.defenseTimer = null;
        this.isGuardWindow = false;
        this.guardStart = 0;
        this.timeScale = 1;
        this.skipLottery = false;
        this.acquiredTitles = new Set();
        this.fastClears = 0;
        this.reviveCount = 0;
        this.noDamageStreak = 0;
    }

    bindDOM() {
        this.el = {
            container: document.getElementById('game-container'),
            hp: document.getElementById('disp-hp'), mp: document.getElementById('disp-mp'),
            lv: document.getElementById('disp-lv'), atk: document.getElementById('disp-atk'), def: document.getElementById('disp-def'),
            gold: document.getElementById('disp-gold'), gen: document.getElementById('disp-gen'),
            weapon: document.getElementById('disp-weapon'), armor: document.getElementById('disp-armor'), acc: document.getElementById('disp-acc'),
            aura: document.getElementById('disp-aura'), chain: document.getElementById('disp-chain'), awakeTxt: document.getElementById('awake-txt'),
            title: document.getElementById('disp-title'),
            log: document.getElementById('log'), stage: document.getElementById('stage'), enemy: document.getElementById('enemy-slot'),
            bar: document.getElementById('progress-bar'), txt: document.getElementById('progress-text'),
            
            modalGo: document.getElementById('modal-go'), modalShop: document.getElementById('shop-modal'), modalLib: document.getElementById('lib-modal'),
            modalHelp: document.getElementById('help-modal'),
            drama: document.getElementById('drama-window'), flash: document.getElementById('flash'), flashInv: document.getElementById('flash-invert'), cutin: document.getElementById('cutin'),
            damagePop: document.getElementById('damage-pop'), chainPop: document.getElementById('chain-pop'),
            dangerOverlay: document.getElementById('danger-overlay'), itemPop: document.getElementById('item-pop'),
            
            menuBattle: document.getElementById('menu-battle'), menuSkills: document.getElementById('menu-skills'), menuChest: document.getElementById('menu-chest'),
            gaugeArea: document.getElementById('gauge-area'), gaugeCursor: document.getElementById('gauge-cursor'),
            
            btnMain: document.getElementById('btn-main'), btnStop: document.getElementById('btn-stop'),
            btnSpeed: document.getElementById('btn-speed'),
            
            chestDisplay: document.getElementById('chest-display'),
            curI: { icon:document.getElementById('cur-icon'), name:document.getElementById('cur-name'), stat:document.getElementById('cur-stat'), sub:document.getElementById('cur-sub'), eff:document.getElementById('cur-effect') },
            newI: { icon:document.getElementById('new-icon'), name:document.getElementById('new-name'), stat:document.getElementById('new-stat'), sub:document.getElementById('new-sub'), eff:document.getElementById('new-effect') },
            
            eventDisplay: document.getElementById('event-display'), eventTitle: document.getElementById('event-title'), eventDesc: document.getElementById('event-desc'), eventChoices: document.getElementById('event-choices'),

            dramaActor: document.getElementById('drama-actor-box'), dramaName: document.getElementById('drama-name'), dramaText: document.getElementById('drama-text'),
            
            btnGet: document.getElementById('btn-get'), btnDiscard: document.getElementById('btn-discard')
        };
    }
    
    resetInternalState() {
        let save = JSON.parse(localStorage.getItem(SAVE_KEY) || 'null');
        this.boosts = save?.boosts || { hp: 0, mp: 0, atk: 0, def: 0, luck: 0 };
        this.clears = save?.clears || 1; 
        this.acquiredTitles = new Set(save?.titles || []);
        if (save) {
            this.generation = save.generation || 1; this.gold = save.gold || 0; this.acquiredItems = new Set(save.library || []);
        } else {
            this.generation = 1; this.gold = 0; this.acquiredItems = new Set();
        }
        this.state = "INIT"; this.lv = 1;
        this.maxHp = 25 + this.boosts.hp; this.hp = this.maxHp;
        this.maxMp = 10 + this.boosts.mp; this.mp = this.maxMp;
        this.baseAtk = 3 + this.boosts.atk;
        this.weapon = null; this.armor = null; this.accessory = null;
        this.luckBonus = Math.min(0.30, this.boosts.luck * 0.02); 
        this.enemy = { name: "", hp: 0, maxHp: 0, atk: 0, type: "slime" };
        this.chain = 0;
        this.isDefenseMode = false;
        if(this.defenseTimer) clearInterval(this.defenseTimer);
        
        // Title Effects
        if(this.acquiredTitles.has("t_survivor")) this.maxHp = Math.floor(this.maxHp * 1.2);
    }
    
    saveData() {
        localStorage.setItem(SAVE_KEY, JSON.stringify({
            generation: this.generation + 1, gold: this.gold, library: Array.from(this.acquiredItems),
            boosts: this.boosts, clears: this.clears, titles: Array.from(this.acquiredTitles)
        }));
    }

    resetSaveData() {
        if(confirm("記憶を消去しますか？\n(セーブデータがリセットされます)")) {
            localStorage.removeItem(SAVE_KEY);
            location.reload();
        }
    }
    
    softReset() {
        this.resetInternalState();
        this.el.log.innerHTML = `<div class='log-entry system'>第${this.generation}代 勇者、運命の地へ。</div>`;
        this.el.modalGo.style.display = "none"; this.el.modalShop.style.display = "none";
        this.el.btnMain.textContent = "運命の抽選へ"; this.el.btnMain.style.display = "block";
        this.el.menuBattle.style.display = "none"; this.el.enemy.innerHTML = "";
        this.el.dangerOverlay.style.display = "none"; this.updateHud();
        this.el.aura.textContent = "READY"; this.el.aura.style.color = "#fff";
        this.sound.playSE('select');
    }

    initAudio() {
        this.sound.init(); this.sound.playSE('select');
        document.getElementById('click-start').style.display = 'none';
        this.el.btnMain.style.display = "block";
        this.log(`第${this.generation}代 勇者、<ruby>冒険の書<rt>クロニクル</rt></ruby>を開いた。`); this.updateHud();
    }
    
    toggleSpeed() {
        if(this.timeScale === 1) {
            this.timeScale = 2;
            this.el.container.classList.add('speed-x2');
            this.el.btnSpeed.textContent = "x2";
            this.el.btnSpeed.style.background = "#044";
        } else {
            this.timeScale = 1;
            this.el.container.classList.remove('speed-x2');
            this.el.btnSpeed.textContent = "x1";
            this.el.btnSpeed.style.background = "#222";
        }
        this.sound.playSE('select');
    }

    log(msg, type = "") {
        if (Math.random() < 0.15 && type === "") {
            const flavor = FLAVOR_TEXTS[Math.floor(Math.random() * FLAVOR_TEXTS.length)];
            const fd = document.createElement('div'); fd.className = "log-entry flavor"; fd.innerHTML = flavor;
            this.el.log.prepend(fd);
        }
        const d = document.createElement('div'); d.className = `log-entry ${type}`; d.innerHTML = msg;
        this.el.log.prepend(d);
        if (this.el.log.children.length > 20) this.el.log.removeChild(this.el.log.lastChild);
    }

    renderEnemy(t, metal, boss) { 
        let d = SPRITES[t] || SPRITES.slime; 
        let color = d.color;
        if (!metal && !boss) { const hues = [d.color, "#f44", "#4f4", "#fd0", "#f0f", "#48f"]; color = hues[this.lv % hues.length]; }
        if (t === "asura" || t === "demon") color = "#f4f"; 
        if (t === "general" || t === "knight") color = "#8af"; 
        if (boss && t === "boss") color = this.clears > 5 ? "#a00" : "#d44"; 
        this.el.enemy.innerHTML = generateSVG({...d, color: color}, null, metal);
    }

    get totalAtk() { 
        let a = this.baseAtk + (this.weapon ? this.weapon.atk : 0) + (this.accessory ? (this.accessory.atk||0) : 0);
        // Soul Effects
        if(this.accessory && this.accessory.soulEffect === "atk_up") a += (this.accessory.val || 0);
        if(this.accessory && this.accessory.soulEffect === "all_up") a += (this.accessory.val || 0);
        return Math.floor(a);
    }
    get totalDef() { 
        return (this.armor ? this.armor.def : 0) + (this.accessory ? (this.accessory.def||0) : 0) + (this.boosts.def || 0); 
    }

    checkDefenseMode() {
        if (this.chain >= 5 && !this.isDefenseMode) {
            this.isDefenseMode = true;
            this.el.container.classList.add('defense-mode');
            this.el.awakeTxt.style.display = "inline";
            this.sound.playSE('revive'); // Use revive sound for activation
            this.log("≪絶対防御界≫ 展開！", "block");
            this.showCutin("A. DEFENSE");
            
            // MP Drain Timer (1 per sec)
            if(this.defenseTimer) clearInterval(this.defenseTimer);
            this.defenseTimer = setInterval(() => {
                if(!this.isDefenseMode) return;
                this.mp = Math.max(0, this.mp - 1);
                this.updateHud();
                if(this.mp <= 0) this.breakDefenseMode();
            }, 1000 / this.timeScale);

        } else if (this.chain < 5 && this.isDefenseMode) {
            this.breakDefenseMode();
        }
    }
    
    breakDefenseMode() {
        this.isDefenseMode = false;
        this.el.container.classList.remove('defense-mode');
        this.el.awakeTxt.style.display = "none";
        if(this.defenseTimer) clearInterval(this.defenseTimer);
        if(this.mp <= 0) this.log("MP枯渇…結界消失。", "damage");
    }

    updateHud() {
        if(!this.el.hp) return;
        this.el.hp.textContent = this.hp; this.el.mp.textContent = this.mp;
        this.el.lv.textContent = this.lv; this.el.atk.textContent = this.totalAtk; this.el.def.textContent = this.totalDef;
        this.el.gold.textContent = this.gold; this.el.gen.textContent = this.generation;
        this.el.weapon.textContent = this.weapon ? this.weapon.name.replace(/<rt>.*?<\/rt>/g,"") : "素手";
        this.el.armor.textContent = this.armor ? this.armor.name.replace(/<rt>.*?<\/rt>/g,"") : "服";
        this.el.acc.textContent = this.accessory ? this.accessory.name.replace(/<rt>.*?<\/rt>/g,"") : "なし";
        this.el.chain.textContent = this.chain;
        this.el.hp.className = this.hp <= this.maxHp * 0.2 ? "val-hp hp-danger" : "val-hp";
        this.el.dangerOverlay.style.display = this.hp <= this.maxHp * 0.25 ? "block" : "none";
        const prog = Math.min(100, (this.lv / this.targetLv) * 100);
        this.el.bar.style.width = `${prog}%`;
        this.el.txt.textContent = this.lv >= this.targetLv ? "決戦！ 魔王の間" : `魔王城まで あと${this.targetLv - this.lv}階`;
        
        // Title
        if(this.acquiredTitles.size > 0) {
            const last = Array.from(this.acquiredTitles).pop();
            const tData = TITLES.find(t=>t.id===last);
            if(tData){ this.el.title.innerHTML = tData.name; this.el.title.style.display="inline"; }
        }
    }

    async delay(ms) { return new Promise(r => setTimeout(r, ms / this.timeScale)); }

    // --- MAIN FLOW ---
    handleMainBtn() { 
        this.sound.playSE('select'); 
        if (this.state === "INIT") this.startLottery(); 
        else if (this.state === "LOTTERY") this.skipLottery = true;
        else if (this.state === "BATTLE_WAIT") this.decideEncounter(); 
    }

    async startLottery() {
        this.state = "LOTTERY"; this.skipLottery = false;
        this.log("運命の抽選を開始... (クリックでスキップ)"); this.sound.playBGM('boss');
        let sel = RATES[0];
        
        const rollCount = 15;
        for (let i = 0; i < rollCount; i++) {
            if (this.skipLottery) break; // Skip
            sel = RATES[Math.floor(Math.random() * RATES.length)];
            this.el.aura.textContent = `${Math.floor(Math.random()*99)}%`;
            this.el.aura.style.color = sel.color;
            if(i%4===0) this.sound.playSE('attack');
            await this.delay(50);
        }
        
        const r = Math.random();
        if (r < 0.2) sel = RATES[0]; else if (r < 0.5) sel = RATES[1]; else if (r < 0.7) sel = RATES[2];
        else if (r < 0.9) sel = RATES[3]; else if (r < 0.98) sel = RATES[4]; else sel = RATES[5];
        this.revivalRate = Math.min(0.65, sel.rate + this.luckBonus); 
        
        // Title Bonus
        if(this.acquiredTitles.has("t_unscathed")) this.revivalRate += 0.05;
        
        this.el.aura.textContent = `${Math.floor(this.revivalRate*100)}%`;
        this.el.aura.style.color = sel.color;
        this.el.stage.style.boxShadow = `inset 0 0 30px ${sel.color}`;
        this.showCutin(sel.name + " 確定"); this.sound.playSE('crit');
        
        if(!this.skipLottery) await this.delay(1000);
        
        this.el.btnMain.textContent = "魔窟へ"; 
        this.state = "BATTLE_WAIT"; this.sound.stopBGM();
    }
    
    decideEncounter() {
        // Dungeon Event Logic
        const r = Math.random();
        if (this.lv < this.targetLv && r < 0.15) {
            this.triggerEvent();
        } else {
            this.startBattle();
        }
    }

    triggerEvent() {
        this.state = "EVENT"; this.el.btnMain.style.display="none";
        this.el.eventDisplay.style.display = "flex"; this.el.eventChoices.innerHTML = "";
        this.el.enemy.style.display = "none";
        
        const events = ["spring", "merchant", "devil"];
        const type = events[Math.floor(Math.random()*events.length)];
        
        let title="", desc="";
        
        const createBtn = (txt, cb) => {
            const b = document.createElement("button"); b.textContent = txt;
            b.onclick = () => { this.sound.playSE('select'); cb(); this.endEvent(); };
            this.el.eventChoices.appendChild(b);
        };
        
        if (type === "spring") {
            title = "回復の泉"; desc = "清らかな水が湧き出ている...";
            createBtn("飲む (HP全回復)", () => { this.hp = this.maxHp; this.log("体力が全回復した！", "revive"); this.sound.playSE('revive'); });
            createBtn("立ち去る", () => {});
        } else if (type === "merchant") {
            title = "謎の行商人"; desc = "「いい薬、あるよ...」";
            const cost = 500 * this.generation;
            createBtn(`薬を買う (${cost}G)`, () => {
                if(this.gold >= cost) { this.gold -= cost; this.hp = Math.min(this.maxHp, this.hp+50); this.log("怪しい薬を飲んで回復した！"); }
                else { this.log("お金が足りない..."); }
            });
            createBtn("立ち去る", () => {});
        } else if (type === "devil") {
            title = "悪魔の契約"; desc = "「HP最大値を捧げれば、力をやろう...」";
            createBtn("契約 (最大HP-10 / 攻+5)", () => {
                if(this.maxHp > 15) { this.maxHp -= 10; this.hp = Math.min(this.hp, this.maxHp); this.boosts.atk += 5; this.log("寿命を削り力を得た...", "damage"); this.sound.playSE('crit'); }
            });
            createBtn("拒絶", () => {});
        }
        
        this.el.eventTitle.textContent = title;
        this.el.eventDesc.textContent = desc;
    }
    
    endEvent() {
        this.el.eventDisplay.style.display = "none";
        this.el.enemy.style.display = "block";
        this.updateHud();
        this.state = "BATTLE_WAIT"; this.el.btnMain.style.display = "block";
    }

    startBattle() {
        this.state = "BATTLE_CMD"; this.el.btnMain.style.display = "none"; this.el.menuBattle.style.display = "grid"; this.el.itemPop.style.transform = "scale(0)";
        this.noDamageNow = true;
        if (this.lv >= this.targetLv) { this.startBossBattle("boss"); return; }
        if (this.lv === 10 || this.lv === 20) { this.startBossBattle("mid"); return; }
        if(!this.isDefenseMode) this.sound.playBGM('battle');
        
        let type = "slime", eName = "スライム", gauge="normal", metal=false, goldMult=1, expMult=1;
        const tier = Math.floor((this.lv - 1) / 3);
        
        if (Math.random() < 0.1) { 
            if (Math.random() < 0.5) { type="metal_s"; eName="メタルスライム"; gauge="fast"; metal=true; expMult=20; }
            else { type="goldman"; eName="ゴールドマン"; gauge="normal"; goldMult=30; }
        } else {
            const types = ["slime", "bat", "rabbit", "skeleton", "ghost", "knight", "wizard", "golem", "mimic", "cerberus", "dullahan", "chimera", "demon", "dragon", "lich", "fallen", "angel", "reaper"];
            type = types[Math.min(tier, types.length-1)] || "slime";
            const pres = ["", "<ruby>凶暴<rt>マッド</rt></ruby>な", "<ruby>歴戦<rt>ベテラン</rt></ruby>の", "<ruby>暗黒<rt>ダーク</rt></ruby>の", "<ruby>真<rt>シン</rt></ruby>・", "<ruby>極<rt>アルティメット</rt></ruby>・", "<ruby>獄炎<rt>インフェルノ</rt></ruby>の"];
            const pre = pres[Math.min(Math.floor(this.lv/5) + Math.floor(this.generation/2), 6)];
            
            // Name mapping with Ruby
            const nameMap = {
                slime: "スライム", bat: "バット", rabbit: "ラビット", skeleton: "スケルトン", ghost: "ゴースト",
                knight: "ナイト", wizard: "ウィザード", golem: "ゴーレム", mimic: "<ruby>人食い箱<rt>ミミック</rt></ruby>",
                cerberus: "ケルベロス", dullahan: "デュラハン", chimera: "キメラ", demon: "デーモン",
                dragon: "ドラゴン", lich: "リッチ", fallen: "<ruby>堕天使<rt>フォールン</rt></ruby>", angel: "<ruby>天使<rt>エンジェル</rt></ruby>", reaper: "<ruby>死神<rt>グリムリーパー</rt></ruby>"
            };

            eName = pre + (nameMap[type] || type);
            gauge = tier > 4 ? (tier > 8 ? "super_fast" : "fast") : "normal";
            
            if (type === "ghost" || type === "fallen") gauge = "blink";
            if (type === "mimic" || type === "dullahan") gauge = "stop_go";
            if (type === "reaper" || type === "lich") gauge = "reverse";
            if (tier > 7 && Math.random() < 0.3) gauge = "wavy";
        }
        
        // INFLATION FORMULA
        let diff = Math.pow(1.2, this.generation - 1) * (1 + (this.lv * 0.1));
        
        this.enemy = { 
            name: eName, type: type, 
            maxHp: Math.floor((20 + Math.pow(this.lv, 1.8)) * diff), 
            hp: Math.floor((20 + Math.pow(this.lv, 1.8)) * diff),
            atk: Math.floor((5 + Math.pow(this.lv, 1.5)) * diff), 
            gaugeType: gauge, isMetal: metal, expMult, goldMult 
        };
        
        this.renderEnemy(type, metal);
        this.el.enemy.style.opacity = 0;
        this.el.enemy.style.transform = "scale(0.5)";
        requestAnimationFrame(() => { 
             this.el.enemy.style.transition = "all 0.5s";
             this.el.enemy.style.opacity = 1; 
             this.el.enemy.style.transform = "scale(1)";
        });
        
        if (Math.random() < 0.6) { 
            const line = TALK_PATTERNS.start[Math.floor(Math.random() * TALK_PATTERNS.start.length)];
            this.showBattleTalk(line, 2000);
        }
        
        this.log(`${this.enemy.name} (HP:${this.enemy.hp}) があらわれた！`);
    }
    
    async startBossBattle(type) {
        if(!this.isDefenseMode) this.sound.playBGM('boss');
        const isMaou = type === "boss";
        // INFLATION
        const diff = Math.pow(1.3, this.generation - 1); 
        
        let name = isMaou ? `第${this.clears}代 <ruby>魔王<rt>ダークロード</rt></ruby>` : "<ruby>魔界<rt>アビス</rt></ruby>の<ruby>番人<rt>ガーディアン</rt></ruby>";
        let eType = isMaou ? "boss" : (Math.random() < 0.5 ? "asura" : "general");
        
        const baseHp = isMaou ? 1000 : 500;
        const baseAtk = isMaou ? 50 : 30;

        this.enemy = { 
            name: name, type: eType, 
            maxHp: Math.floor(baseHp * diff * (1+this.lv*0.1)), 
            hp: Math.floor(baseHp * diff * (1+this.lv*0.1)), 
            atk: Math.floor(baseAtk * diff * (1+this.lv*0.05)), 
            gaugeType: "super_fast", isMetal: false, expMult: 3, goldMult: 100 
        };
        
        this.renderEnemy(this.enemy.type, false, true);
        this.el.stage.style.background = "#301";
        this.el.enemy.style.opacity = 0;
        this.el.enemy.style.transform = "scale(2)";
        requestAnimationFrame(() => { 
             this.el.enemy.style.transition = "all 2s";
             this.el.enemy.style.opacity = 1; 
             this.el.enemy.style.transform = "scale(1.2)";
        });
        
        // Boss Talk
        const line = isMaou ? "よくぞここまで来た…褒めてやろう" : "ここを通すわけにはいかん…";
        setTimeout(() => this.showBattleTalk(line, 3000), 1000);

        this.showCutin(isMaou ? "魔王 降臨" : "強敵 出現");
    }
    
    showBattleTalk(text, duration, actorKey = null, nameOverride = null) {
        this.el.drama.style.display = "flex";
        const key = actorKey || this.enemy.type;
        const name = nameOverride || this.enemy.name;
        this.el.dramaActor.innerHTML = generateSVG(SPRITES[key] || SPRITES.slime);
        this.el.dramaName.innerHTML = name;
        this.el.dramaText.textContent = text;
        if (this.dramaTimer) clearTimeout(this.dramaTimer);
        this.dramaTimer = setTimeout(() => { this.el.drama.style.display = "none"; }, duration);
    }

    // --- COMBAT ---
    selectAttack() { this.sound.playSE('select'); this.selectedSkill = null; this.el.menuBattle.style.display = "none"; this.startGauge(); }
    selectHeal() { this.sound.playSE('select'); if(this.mp<5){this.log("MP不足！");return;} this.useSkill(SKILLS.find(s=>s.id==="heal")); }
    
    openSkills() {
        this.sound.playSE('select'); this.el.menuBattle.style.display = "none"; this.el.menuSkills.style.display = "grid"; this.el.menuSkills.innerHTML = "";
        const addBtn = (s) => {
            const b = document.createElement('button'); b.innerHTML = `${s.name}<br><span style="font-size:0.8rem">MP:${s.mp}</span>`;
            b.onclick = () => this.useSkill(s); if(this.mp<s.mp) b.disabled=true; this.el.menuSkills.appendChild(b);
        };
        if(this.weapon && this.weapon.skillId) addBtn(SKILLS.find(s=>s.id===this.weapon.skillId));
        if(this.lv>=3) addBtn(SKILLS.find(s=>s.id==="heal"));
        const back = document.createElement('button'); back.textContent="もどる"; back.onclick=()=>{this.sound.playSE('select');this.el.menuSkills.style.display="none";this.el.menuBattle.style.display="grid";};
        this.el.menuSkills.appendChild(back);
    }
    
    useSkill(skill) {
        this.sound.playSE('select'); this.mp -= skill.mp; this.updateHud();
        if(skill.type==="heal") {
            let h = skill.heal + Math.floor(Math.random()*10) + this.boosts.atk;
            this.hp = Math.min(this.maxHp, this.hp+h); this.updateHud(); this.showDamage(h, 'heal', false);
            this.log(`${skill.name}！ 体力が ${h} 回復した！`, "revive"); this.sound.playSE('revive');
            this.el.menuSkills.style.display="none"; setTimeout(()=>this.enemyTurn(),800);
        } else {
            this.selectedSkill = skill; this.el.menuSkills.style.display="none"; this.startGauge();
        }
    }

    handleActionBtn() {
        if(this.state === "GAUGE") this.stopGauge();
        else if(this.state === "ENEMY_TURN" && this.isGuardWindow) this.attemptGuard();
    }

    startGauge() {
        this.state = "GAUGE"; 
        this.el.btnStop.style.display="block"; 
        this.el.btnStop.className = "main-btn btn-stop";
        this.el.btnStop.textContent = "たたかう！";
        
        this.el.gaugeArea.style.display="block";
        this.gaugeVal=0; this.gaugeDir=1;
        this.gaugeSpeed = (2 + (this.lv*0.1)) * (this.enemy.gaugeType==="fast"?1.5:(this.enemy.gaugeType==="super_fast"?2.5:1));
        if(this.enemy.gaugeType === "slow") this.gaugeSpeed = 0.5;
        
        if(this.weapon && this.weapon.effect === "slow") this.gaugeSpeed *= 0.7;
        
        // Haste Soul
        if(this.accessory && this.accessory.effect === "haste") this.gaugeSpeed *= 0.8;

        this.el.gaugeCursor.style.opacity = 1;
        this.runGauge();
    }
    runGauge() {
        if(this.state!=="GAUGE") return;
        let spd = this.gaugeSpeed;
        const t = this.enemy.gaugeType;
        if (t === "stop_go") { if (Math.random() < 0.1) spd = 0; }
        else if (t === "blink") { this.el.gaugeCursor.style.opacity = (Math.floor(Date.now() / 100) % 2) ? 0 : 1; }
        else if (t === "wavy") { spd = this.gaugeSpeed * (Math.sin(Date.now() / 200) + 1.5); }
        if (t === "reverse") { if (this.gaugeDir === 1) this.gaugeVal -= spd; else this.gaugeVal += spd; } else { this.gaugeVal += spd * this.gaugeDir; }

        if(this.gaugeVal>=100){this.gaugeVal=100;this.gaugeDir=-1;} if(this.gaugeVal<=0){this.gaugeVal=0;this.gaugeDir=1;}
        this.el.gaugeCursor.style.left = this.gaugeVal+"%"; requestAnimationFrame(()=>this.runGauge());
    }
    
    async stopGauge() {
        if(this.state!=="GAUGE") return; this.state="ANIM"; this.el.btnStop.style.display="none";
        this.sound.playSE('attack');
        let dist = Math.abs(50-this.gaugeVal), mult=1.0, isCrit=false;
        
        let safeZone = 5;
        if (this.weapon && this.weapon.effect === "scope") safeZone = 10;
        // Godspeed Title
        if(this.acquiredTitles.has("t_godspeed")) safeZone += 2;

        if(dist <= safeZone) {
            this.chain++; 
            isCrit = true;
            mult = 1.2 + (this.chain * 0.3); 
            // Crit Soul
            if(this.accessory && this.accessory.effect === "crit_up") mult += 0.5;
            this.showChainPop(`${this.chain} CHAIN!`);
            this.checkDefenseMode(); 
        } else if (dist <= 15) { 
            if (this.enemy.isMetal && Math.random() < 0.5) { isCrit = true; this.log("神速の剣閃！", "critical"); }
            mult = 1.0; this.chain = 0; this.checkDefenseMode(); 
        } else {
            if(this.chain > 0) this.log("集中力が途切れた...", "damage");
            this.chain = 0; mult = 0.5; this.checkDefenseMode(); 
        }
        
        await this.delay(300); this.el.gaugeArea.style.display="none";
        await this.performAttack(mult, isCrit);
    }

    async performAttack(mult, isCrit) {
        this.el.enemy.classList.add("anim-shake"); 
        let dmgBase = this.totalAtk * (this.selectedSkill ? this.selectedSkill.dmg : 1.0);
        let times = this.selectedSkill && this.selectedSkill.times ? this.selectedSkill.times : 1;
        
        for(let i=0; i<times; i++) {
            let dmg = Math.floor(dmgBase * mult);
            if(this.enemy.isMetal) {
                dmg = (isCrit || (this.weapon&&this.weapon.id==="metal_w")) ? this.enemy.maxHp : (Math.random()<0.5 ? 0 : 1);
                if(dmg>0) this.sound.playSE('metal');
            } else {
                if(isCrit) { this.showCutin("会心の一撃"); this.sound.playSE('crit'); } else { this.sound.playSE('hit'); }
            }
            if(dmg>0) { 
                this.log(`${this.enemy.name}に ${dmg} のダメージ！`, isCrit ? "critical" : "");
                this.showDamage(dmg, 'deal', isCrit); this.enemy.hp-=dmg; 
                
                // Enemy React Talk
                if (this.enemy.hp < this.enemy.maxHp * 0.3 && Math.random() < 0.4) {
                    this.showBattleTalk(TALK_PATTERNS.pinch[Math.floor(Math.random()*TALK_PATTERNS.pinch.length)], 1000);
                } else if (Math.random() < 0.2) {
                    this.showBattleTalk(TALK_PATTERNS.hit[Math.floor(Math.random()*TALK_PATTERNS.hit.length)], 1000);
                }

                // Drain Effect
                if ((this.weapon && this.weapon.effect === "drain") || (this.accessory && this.accessory.effect === "drain")) {
                     let drain = Math.floor(dmg * 0.2);
                     if(drain > 0) {
                         this.hp = Math.min(this.maxHp, this.hp + drain);
                         this.log(`血を啜り ${drain} 回復！`, "revive");
                     }
                }

            } else { 
                this.log(`ミス！ ${this.enemy.name}にダメージを与えられない！`); this.showDamage("Miss", 'miss', false); 
            }
            await this.delay(200);
        }
        this.updateHud(); this.el.enemy.classList.remove("anim-shake");
        if(this.enemy.hp<=0) this.winBattle(); else this.enemyTurn();
    }

    async enemyTurn() {
        this.state = "ENEMY_TURN";
        await this.delay(400);
        
        if (this.enemy.isMetal && Math.random() < 0.5) {
            this.log(`${this.enemy.name}は逃げ出した！`, "system");
            this.el.enemy.style.opacity = 0;
            await this.delay(1000);
            this.state = "BATTLE_WAIT"; this.el.btnMain.style.display = "block"; this.el.btnMain.textContent = "さらに奥へ";
            return;
        }

        this.log(`${this.enemy.name}の攻撃構え！`, "damage");
        this.el.enemy.classList.add("anim-lunge");
        
        this.el.btnStop.style.display = "block";
        this.el.btnStop.className = "main-btn btn-guard";
        this.el.btnStop.textContent = "防御！";
        
        this.isGuardWindow = true;
        this.guardStart = Date.now();
        this.guardSuccess = false;
        
        await this.delay(600);
        
        this.isGuardWindow = false;
        this.el.btnStop.style.display = "none";
        this.el.enemy.classList.remove("anim-lunge");

        // CHECK DEFENSE MODE
        if (this.isDefenseMode) {
             this.sound.playSE('metal');
             this.log(`絶対防御界がダメージを無効化した！`, "block");
             this.showDamage("BLOCK", 'block', false);
             // Extra MP cost for block
             this.mp = Math.max(0, this.mp - 2); 
             if(this.mp <= 0) this.breakDefenseMode();
             this.updateHud();
             this.state = "BATTLE_CMD"; this.el.menuBattle.style.display = "grid";
             return; // No damage taken
        }

        if (this.guardSuccess) {
            // JUST GUARD SUCCESS
            let counterDmg = Math.floor(this.totalAtk * 1.5);
            this.log(`カウンター！ ${this.enemy.name}に ${counterDmg} のダメージ！`, "critical");
            this.showDamage(counterDmg, 'deal', true);
            this.enemy.hp -= counterDmg;
            this.sound.playSE('crit');
            if(this.enemy.hp<=0) { this.winBattle(); return; }
        } else {
            this.noDamageNow = false;
            let dmg = Math.max(1, this.enemy.atk - Math.floor(Math.random()*3));
            
            if (this.armor && this.armor.effect === "reflect") {
                 let ref = Math.floor(dmg * 0.3);
                 if(ref > 0) { this.enemy.hp -= ref; this.log(`呪詛返し！敵に ${ref} ダメージ！`, "damage"); }
            }

            dmg = Math.max(1, Math.floor(dmg - (this.totalDef / 2)));
            if(Math.random()<0.15 && !this.enemy.isMetal) { dmg=Math.floor(dmg*1.5); this.log("痛恨の一撃！","damage"); }
            
            this.hp-=dmg; this.updateHud(); 
            this.log(`${dmg} のダメージを受けた！`, "damage"); this.showDamage(dmg, 'take', false); this.sound.playSE('hit');
            this.el.stage.style.transform = "translate(5px, 5px)"; setTimeout(() => this.el.stage.style.transform = "translate(0, 0)", 100);
        }

        // Regen Effect (Armor or Soul)
        if ((this.armor && this.armor.effect === "regen") || (this.accessory && this.accessory.effect === "regen")) {
            let reg = Math.floor(this.maxHp * 0.05);
            if(reg>0 && this.hp > 0) { this.hp = Math.min(this.maxHp, this.hp+reg); this.updateHud(); }
        }

        if (this.hp <= 0) {
            // Rebirth Accessory
            if(this.accessory && this.accessory.effect === "rebirth") {
                this.hp = Math.floor(this.maxHp * 0.5);
                this.log("フェニックスの尾が輝き、蘇る！", "revive");
                this.accessory = null; // Consume
                this.updateHud();
                this.sound.playSE('revive');
                this.showCutin("復 活");
                this.state = "BATTLE_CMD"; this.el.menuBattle.style.display = "grid";
            } else {
                this.sound.stopBGM();
                await this.tryRevival();
            }
        } else {
            this.state = "BATTLE_CMD"; this.el.menuBattle.style.display = "grid";
        }
    }
    
    attemptGuard() {
        if(!this.isGuardWindow) return;
        const now = Date.now();
        if (now - this.guardStart <= 250) {
            this.guardSuccess = true;
            this.isGuardWindow = false;
            this.sound.playSE('parry');
            
            // NEW: Just Guard Effect
            this.el.flashInv.classList.add("anim-invert");
            setTimeout(() => this.el.flashInv.classList.remove("anim-invert"), 300);

            // NEW: Kanji + Ruby Text
            const txtObj = GUARD_TEXTS[Math.floor(Math.random()*GUARD_TEXTS.length)];
            const rubyHtml = `<ruby>${txtObj.t}<rt>${txtObj.r}</rt></ruby>`;
            
            this.el.cutin.innerHTML = rubyHtml;
            this.el.cutin.style.transform="translate(-50%,-50%) scale(1)";
            this.el.cutin.classList.add("just");
            
            setTimeout(()=>{
                this.el.cutin.style.transform="translate(-50%,-50%) scale(0)";
                this.el.cutin.classList.remove("just");
            }, 1000);

            this.log("見切った！", "critical");
        } else {
            this.log("防御が遅れた！");
        }
    }

    // --- WIN & DROP ---
    async winBattle() {
        if (this.noDamageNow) {
            this.noDamageStreak++;
            if (this.noDamageStreak >= 5 && !this.acquiredTitles.has("t_unscathed")) {
                this.acquiredTitles.add("t_unscathed");
                this.log("称号≪無傷の帝王≫を獲得！(運UP)", "critical");
                this.saveData();
            }
        } else {
            this.noDamageStreak = 0;
        }

        if (this.enemy.type === "boss") {
            this.sound.stopBGM();
            this.sound.playBGM('clear');
            this.log(`魔王を討伐した！`, "critical");
            this.showBattleTalk(TALK_PATTERNS.die[Math.floor(Math.random()*TALK_PATTERNS.die.length)], 2000);
            
            this.el.enemy.style.transition = "all 2s";
            this.el.enemy.style.opacity = 0;
            this.el.enemy.style.filter = "brightness(5)";
            this.showCutin("完全勝利");
            await this.delay(3000);
            
            this.clears++;
            this.gold += 10000;
            this.saveData();
            
            this.log("世界に平和が戻った...", "revive");
            this.log(`クリア回数: ${this.clears}`, "revive");
            await this.delay(2000);
            
            this.el.stage.style.background = "#111"; 
            this.openShop();
            return;
        }

        this.log(`${this.enemy.name}を葬った。`, "critical");
        
        // Random Death Talk
        if (Math.random() < 0.3) {
            this.showBattleTalk(TALK_PATTERNS.die[Math.floor(Math.random()*TALK_PATTERNS.die.length)], 1000);
        }

        this.sound.playSE('select'); 
        this.el.enemy.style.transition = "opacity 1s, transform 1s";
        this.el.enemy.style.opacity = 0;
        this.el.enemy.style.transform = "scale(0.1) rotate(180deg)";
        await this.delay(1000);
        
        this.lv += 1;
        
        const mult = this.enemy.expMult;
        this.maxHp += 4 * mult; 
        this.hp = Math.min(this.maxHp, this.hp + 20);
        this.baseAtk += 1 * mult; 
        this.maxMp += 2 * mult; 
        this.mp += 2 * mult;
        
        let goldRate = 1.0;
        if(this.armor && this.armor.effect === "greed") goldRate += 0.5;
        if(this.weapon && this.weapon.effect === "greed") goldRate += 0.5;
        if(this.accessory && this.accessory.effect === "greed") goldRate += 0.5;

        let g = Math.floor((10 + this.lv*2)*this.enemy.goldMult * goldRate); 
        this.gold+=g;
        
        this.updateHud(); 
        this.log(mult > 1 ? `${g}G 強奪。莫大な経験値を得た。(Lv+1)` : `${g}G 獲得。Lv${this.lv}に到達。`);
        this.sound.playSE('coin');
        await this.checkDrop();
    }

    async checkDrop() {
        // Soul Drop Check (Only if not boss, low prob)
        if (Math.random() < 0.05 && SOULS[this.enemy.type]) {
            const soulData = SOULS[this.enemy.type];
            const soulItem = { 
                id: `soul_${this.enemy.type}`, type: "acc", 
                name: soulData.name, atk: 0, def: 0, 
                prob: 0, sprite: "soul", color: soulData.color,
                soulEffect: soulData.effect, effectName: soulData.effectName, val: soulData.val
            };
            this.acquiredItems.add(soulItem.id);
            this.pendingItem = soulItem;
            this.log("敵の魂が具現化した...", "revive");
            await this.showItemCompare(soulItem);
            return;
        }

        if (Math.random() < 0.4) { 
            let drop = ITEMS[Math.floor(Math.random()*ITEMS.length)]; 
            
            // Inflate Item Stats
            let scale = Math.pow(1.15, this.lv/5) * (1 + this.generation * 0.5);
            let newI = JSON.parse(JSON.stringify(drop)); // Clone
            if(newI.atk) newI.atk = Math.floor(newI.atk * scale);
            if(newI.def) newI.def = Math.floor(newI.def * scale);

            this.acquiredItems.add(drop.id);
            this.pendingItem = newI;
            await this.showItemCompare(newI);
        } else {
            this.state="BATTLE_WAIT"; this.el.btnMain.textContent="さらに奥へ"; this.el.btnMain.style.display="block"; 
            if(!this.isDefenseMode) this.sound.playBGM('battle');
        }
    }
    
    showItemCompare(item) {
        return new Promise(resolve => {
            this.el.menuBattle.style.display = "none";
            this.el.chestDisplay.style.display = "flex";
            this.el.enemy.style.display = "none";
            
            this.el.menuChest.style.display = "grid";
            
            // Trap Prevention: Delay inputs
            this.el.btnGet.style.opacity = 0.3; this.el.btnGet.style.pointerEvents = "none";
            this.el.btnDiscard.style.opacity = 0.3; this.el.btnDiscard.style.pointerEvents = "none";
            
            setTimeout(()=>{
                this.el.btnGet.style.opacity = 1; this.el.btnGet.style.pointerEvents = "auto";
                this.el.btnDiscard.style.opacity = 1; this.el.btnDiscard.style.pointerEvents = "auto";
            }, 800);

            const isArmor = item.type === "a";
            const isAcc = item.type === "acc";
            
            let cur;
            if (isAcc) cur = this.accessory || {name:"なし", sprite:"soul", color:"#333"};
            else if (isArmor) cur = this.armor || {name:"旅人の服", def:0, sprite:"a_cloth", color:"#fff"};
            else cur = this.weapon || {name:"素手", atk:0, skillId:null, sprite:"stick", color:"#fff"};
            
            this.renderCard(this.el.curI, cur, item.type);
            this.renderCard(this.el.newI, item, item.type);
            
            this.resolveItem = resolve;
        });
    }
    
    renderCard(els, item, type) {
        if(!els.name) return;
        els.name.innerHTML = item.name; // Use innerHTML for ruby
        const sp = SPRITES[item.sprite] || SPRITES.stick;
        els.icon.innerHTML = generateSVG(sp, item.color);
        
        let statTxt = "";
        if (type === "acc") statTxt = `攻+${item.atk||0} 守+${item.def||0}`;
        else if (type === "a") statTxt = `守+${item.def}`;
        else statTxt = `攻+${item.atk}`;
        els.stat.textContent = statTxt;
        
        let sText = "";
        if (item.skillId) { const s = SKILLS.find(k => k.id === item.skillId); if (s) sText = `技:${s.name.replace(/<rt>.*?<\/rt>/g,"")}`; }
        els.sub.textContent = sText;
        els.eff.textContent = item.effectName ? `★${item.effectName}` : "";
    }
    
    decideItem(take) {
        this.sound.playSE('select');
        if(take) {
            if (this.pendingItem.type === "acc") this.accessory = this.pendingItem;
            else if (this.pendingItem.type === "a") this.armor = this.pendingItem; 
            else this.weapon = this.pendingItem;
            this.log(`${this.pendingItem.name.replace(/<rt>.*?<\/rt>/g,"")}と契約した。`, "item"); this.sound.playSE('revive');
        } else { this.log("宝箱を拒絶した。", "system"); }
        
        this.el.chestDisplay.style.display = "none"; 
        this.el.menuChest.style.display = "none";
        this.el.enemy.style.display = "block";
        
        this.updateHud(); 
        
        this.state="BATTLE_WAIT"; this.el.btnMain.textContent="さらに奥へ"; this.el.btnMain.style.display="block"; 
        if(!this.isDefenseMode) this.sound.playBGM('battle');
        
        if(this.resolveItem) this.resolveItem();
    }

    async tryRevival() {
        this.state="REVIVAL"; this.log("勇者は力尽きた...","damage"); await this.delay(1500);
        this.log("運命の天秤が揺れる...", "system"); await this.delay(1000);
        
        if (Math.random() < this.revivalRate) {
            await this.playRevivalDrama();
            this.reviveCount++;
            if(this.reviveCount >= 1 && !this.acquiredTitles.has("t_immortal")) {
                this.acquiredTitles.add("t_immortal");
            }
            this.hp = Math.floor(this.maxHp * 0.6);
            this.updateHud();
            if(!this.isDefenseMode) this.sound.playBGM('boss');
            this.state = "BATTLE_CMD";
            this.el.menuBattle.style.display = "grid";
        } else {
            this.log("......", "system");
            await this.delay(1000);
            this.gameOver();
        }
    }

    async playRevivalDrama() {
        const dramas = [
            [{a:"npc_princess",n:"王女",t:"勇者様！ 死なないで！"},{a:"npc_princess",n:"王女",t:"私の祈りよ...届け！！"}],
            [{a:"npc_friend",n:"戦友",t:"おい！ ここでくたばるのか？"},{a:"npc_friend",n:"戦友",t:"立て！ 俺が盾になる！！"}],
            [{a:"npc_king",n:"王様",t:"ええい！ 情けないやつめ！"},{a:"npc_king",n:"王様",t:"特別にもう一度 チャンスをやろう..."}],
            [{a:"npc_healer",n:"神父",t:"おお神よ..."},{a:"npc_healer",n:"神父",t:"この者に 加護を与えたまえ！"}]
        ];
        const scene = dramas[Math.floor(Math.random() * dramas.length)];
        
        this.el.drama.style.display = "flex";
        
        for (const step of scene) {
             this.el.dramaActor.innerHTML = generateSVG(SPRITES[step.a] || SPRITES.slime);
             this.el.dramaName.textContent = step.n;
             this.el.dramaText.textContent = step.t;
             this.sound.playSE('select');
             await this.delay(2500);
        }
        
        this.el.drama.style.display = "none";
        this.el.flash.style.opacity = 1; 
        this.sound.playSE('revive'); 
        this.showCutin("ふ　っ　か　つ");
        this.log("奇跡が起きた！", "revive");
        await this.delay(500); 
        this.el.flash.style.opacity = 0;
    }

    gameOver() {
        this.state = "GAMEOVER";
        this.sound.stopBGM();
        this.saveData();
        document.getElementById('final-score').textContent = this.lv;
        this.el.modalGo.style.display = "flex";
    }

    showDamage(val, t, c){
        const el = this.el.damagePop; el.textContent = val; el.className = "damage-pop";
        if (t === 'deal') { el.classList.add('deal'); if (c) el.classList.add('crit'); }
        else if (t === 'take') el.classList.add('take'); else if (t === 'heal') el.classList.add('heal'); 
        else if (t === 'block') el.classList.add('block');
        else el.classList.add('miss');
        el.style.animation = "none"; el.offsetHeight; el.style.animation = "pop-damage 0.5s forwards";
    }
    showCutin(t){this.el.cutin.innerHTML=t;this.el.cutin.style.transform="translate(-50%,-50%) scale(1)";setTimeout(()=>this.el.cutin.style.transform="translate(-50%,-50%) scale(0)",1500);}
    showChainPop(t) {
        this.el.chainPop.textContent = t;
        this.el.chainPop.style.transform = "translate(-50%,-50%) scale(1.5)";
        this.el.chainPop.style.opacity = 1;
        setTimeout(() => {
             this.el.chainPop.style.transform = "translate(-50%,-50%) scale(1)";
             this.el.chainPop.style.opacity = 0;
        }, 500);
    }
    openHelp() { this.sound.playSE('select'); this.el.modalHelp.style.display="flex"; }
    closeHelp() { this.sound.playSE('select'); this.el.modalHelp.style.display="none"; }
    
    openShop() { this.el.modalGo.style.display="none"; this.el.modalShop.style.display="flex"; document.getElementById('shop-gold').textContent=this.gold; }
    buyBoost(t) {
        let c=0,i=0; 
        if(t==='hp'){c=500;i=5;}
        if(t==='mp'){c=500;i=2;}
        if(t==='atk'){c=1000;i=1;}
        if(t==='def'){c=1000;i=1;}
        if(t==='luck'){c=2000;i=1;}
        
        if(this.gold>=c){this.gold-=c;this.boosts[t]+=i;document.getElementById('shop-gold').textContent=this.gold;this.sound.playSE('coin');this.saveData();} else this.sound.playSE('hit');
    }
    openLibrary() {
        this.sound.playSE('select'); this.el.modalLib.style.display="flex"; document.getElementById('lib-grid').innerHTML="";
        const allItems = [...ITEMS];
        // Add soul items dynamically
        Object.keys(SOULS).forEach(key => {
            const s = SOULS[key];
            allItems.push({id:`soul_${key}`, type:"acc", name:s.name, prob:0, sprite:"soul", color:s.color, isSoul:true});
        });

        allItems.forEach(i=>{
            const div=document.createElement('div'); const has=this.acquiredItems.has(i.id);
            div.className=`lib-item ${has?'got':''} ${i.isSoul?'soul':''}`;
            let label = "";
            if(i.type==="w") label=`攻${i.atk}`; else if(i.type==="a") label=`守${i.def}`; else label="装飾";
            div.innerHTML=`${has?generateSVG(SPRITES[i.sprite],i.color):generateSVG(SPRITES.stick,"#333")}<div>${has?i.name.replace(/<rt>.*?<\/rt>/g,""):"???"}</div><div>${label}</div>`;
            document.getElementById('lib-grid').appendChild(div);
        });
    }
    closeLibrary() { this.sound.playSE('select'); this.el.modalLib.style.display="none"; }
}
window.onload = () => { game = new Game(); game.bindDOM(); };
</script>
</body>
</html>
